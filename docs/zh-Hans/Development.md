# 开发文档 - 输入法助手

**注意：文档正在完善中...（2024-03-30）**

目录：

- [项目生成](#项目生成)

- [目录结构](#目录结构)

- [工作机制](#工作机制)

- [3.6.2 版开始的非重复型快捷键失效问题](#362-版非重复型快捷键失效问题)

- [文本编辑模式中使用 Shift 加鼠标按键导航导致输入模式切换的问题](#文本编辑模式中使用-Shift-加鼠标按键导航导致输入模式切换的问题)

# 项目生成

1. 安装 [Python](https://www.python.org/)

   开发者所有版本：

   - Python 3.11.0

2. 安装 [Visual Studio 2022 Build Tools](https://learn.microsoft.com/zh-cn/visualstudio/install/use-command-line-parameters-to-install-visual-studio?view=vs-2022)

   - 安装 **使用 C++ 的桌面开发** 工作负荷

   - 安装 **Windows SDK**（上述的工作负荷已包含）

   开发者所有版本：

   - Visual Studio 2022 Build Tools 17.14.17

   - MSVC 14.44.35207

   - Windows SDK 10.0.22621.0

   > 如果使用不同的版本，请适当修改 **native/main.vcxproj** 中的 `PlatformToolset` 和 `WindowsTargetPlatformVersion` 属性。

3. 下载依赖库

    需要从 [Blender 的依赖库](https://projects.blender.org/blender/lib-windows_x64) 中获取头文件和静态库文件：

    - freetype

        将 freetype/include/freetype2 复制到 src/native/include/ 中。

        将 freetype/lib/freetype2ST.lib 复制到 src/native/lib/ 中。

    - brotli

        将 brotli/lib/brotlicommon-static.lib 复制到 src/native/lib/ 中。
        
        将 brotli/lib/brotlidec-static.lib 复制到 src/native/lib/ 中。

    - zlib

        将 zlib/lib/libz_st.lib 复制到 src/native/lib/ 中。

4. 在项目目录中执行（自行替换 **{}** 中的内容）：

   ```
   > python make.py build --vsdev "{path to VsDevCmd.bat}"
   ```

   输出的文件在 **xdebug** 目录中。具体请参考 **make.py**。

# 目录结构

源码目录结构：

- `__init__.py`

  插件的入口模块。内容非常简单且通用，真正的入口在 main.py。

- `main.py`

  插件真正的入口模块，负责插件的注册和卸载。

- `prefs.py`

  包含插件的配置选项。

- `ime.py`

  包含插件的主要功能。

- `src/native/`

  主要包含了一个 MSVC 项目，编译后产生一个 DLL 文件。

  通过其中的 `__init__.py` 文件，可以在 Python 脚本中访问该 DLL 导出的功能。

- `src/dev/` (_不重要_)

  包含开发相关的功能。

- `src/debug/` (_不重要_)

  包含调试相关的功能。

- `src/utils/` (_不重要_)

  包含各种不特定于项目的辅助功能。

# 工作机制

**管理器** - `ime.py` - `Manager` 类

大部分核心功能都写在管理器中，包括窗口的捕获和释放，输入法状态的更新等。

**更新器** - `ime.py` - `WIRE_FIX_IME_OT_state_updater` 类

负责更新输入法的启停状态。

**处理器** - `ime.py` - `WIRE_FIX_IME_OT_input_handler` 类

负责处理输入法的输入事件。

## 捕获和释放窗口

插件通过窗口子类化（Win32：SetWindowSubclass）将插件的窗口处理过程插入到 Blender 的窗口处理过程之前，即窗口消息先经过插件的窗口处理过程再经过 Blender 的窗口处理过程。将窗口子类化的行为在这里称为“捕获窗口”，解除窗口子类化称为“释放窗口”。

介入窗口消息的处理后，插件可以在按键消息和输入法消息到来的时候进行特殊处理，从而实现相关的功能。

当鼠标在窗口划过时，插件注册到 Blender 的 `Screen Editting` 按键映射表的更新器会被执行，此时更新器会为当前窗口建立一个关联的管理器（已建立则不再建立），然后在管理器启动的时候，会对当前窗口进行捕获。

当窗口关闭或插件相关选项停用或插件卸载时，会自动对已捕获的窗口进行释放。

`src/native/ime.c` 文件包含了捕获和释放窗口，以及处理窗口消息的逻辑代码。该文件包含了整个 DLL 的核心功能。

## 管理输入法启停

插件在 Blender 的 `Screen Editting` 按键映射表会注册两个映射项，含义为当发生 `MOUSEMOVE` 或 `TIMER` 事件时，执行更新器。

更新器会以高频次的方式执行，为了节省性能，对执行频率进行了限制。当距离上次更新超过一定的时间后才会进行更新。

限制频率虽然节省了性能，但是会导致状态更新不及时，譬如用户移动了一下鼠标，但该事件恰好发生在事件间隔之内，不会执行状态更新，因此此时的输入法状态是落后于当前情况的。

为了解决这个问题，在每次收到合法的更新事件但不满足时间间隔的时候，会主动注册一个计时器，以便在未来触发一次更新。下次合法的更新事件到达时，会先取消上次注册的计时器，然后如果满足时间间隔，则直接更新不注册计时器，否则继续设置新的计时器。通过这种方式使得状态更新总会在最后一个用户触发合法的更新事件之后执行，保证输入法的状态总是符合当前情况。

输入法状态更新的功能需求：

a. 激活输入框，启动输入法。

b. 离开输入框，停用输入法。

c. 鼠标待在特定的编辑器的主区块，且符合启用输入法的条件，则启用输入法。

d. 鼠标离开特定的编辑器的主区块，或不合启用输入法的条件，则停用输入法。

输入法状态更新的实际逻辑：

1. 如果即将或正在通过输入法输入文本，则退出更新。【为了满足需求 d】

2. 更新时，先检查当前输入法的启用者（可能的值：无、输入框、3D 视图文本编辑模式、文本编辑器、控制台）。

3. 如果启用者为输入框，则退出更新。【为了满足需求 a。Blender 自己就实现了需求 a，这里是为了避免插件对其的干扰。】

4. 如果当前存在浮动菜单或面板，则停用输入法，并退出更新。【为了满足需求 d】

5. 检查鼠标所在编辑器是否符合启用输入法的条件，如果符合则启用输入法，否则停用输入法。【为了满足需求 c、b、d】

在 3.0 之前的版本中，状态更新是不准确的，主要原因在于无法准确获取状态更新所需的数据。

在 3.0 开始，通过 BPY 类型提供的 `as_pointer` 函数获取类型实例的内存地址，然后通过指针和偏移获取没有导出到 BPY 的数据。

这使得状态更新变得准确且可靠，当然由此也带来了问题。

由于结构中成员的偏移量在不同的 Blender 版本中可能不同，因此需要对所有支持的版本进行勘查，得到所需成员在各个版本中的偏移量。

这部分的工作是比较艰辛的，但幸好需要的成员并不多，因此在有限的时间内还是能够计算出来。

通过指针访问这些隐藏成员的功能写在 `src/native/blender.c` 文件中。

而这些偏移量的调查数据记录在 `src/native/offset/` 目录中，其使用方式，请参考该目录中的说明。

**注**：更新器额外承担一个和更新无关的功能，就是接收启动处理器的 `TIMER` 事件，然后启动处理器。

## 更新候选窗位置

更新候选窗位置主要会遇到两个问题：

1. 何时更新
2. 如何定位

对于第一个问题，本质上在输入合成开始时进行定位即可，但部分输入法在开始合成后不再理会定位请求，因此必须在开始前进行定位。

由于无法预知用户什么时候即将按下文本合成的第一个按键（按下的时候已经进入合成，而不是即将），所以只能在启用输入法后的任何必要时刻都进行候选窗位置的更新。

这些时机包括（输入框的候选窗定位由 Blender 完成，插件无需干预）：

1. 在编辑器中启用输入法时

2. 编辑器主区块重绘时

对于第二个问题，因为 BPY 并没有提供或很好提供获取文本光标的准确位置的方法，而变成比较复杂。
此外为了绘制合成文本的下划线，还需要更多的绘制参数，而这些也是没有导出到 BPY 的。
因此解决这个问题需要用到指针和偏移量，以及参考源码了解某些绘制参数的计算方式。

具体逻辑请参考 `src/ime.py` 中标注为 “候选框位置更新” 的内容。

## 处理输入法输入

需要处理的输入法消息包括以下的几种：

- `WM_IME_STARTCOMPOSITION`（合成开始消息）

  表示合成的开始。

- `WM_IME_ENDCOMPOSITION`（合成结束消息）

  表示合成的结束。

- `WM_IME_COMPOSITION`（合成更新消息）

  输入法通知窗口合成或结果字符串发生了改变。

  在该消息中，我们需要获取当前的输入法的合成文本和结果文本。

  合成文本表示待转换的文本，但不是最终的内容。在整个合成过程中，该文本会被不断更新。

  结果文本表示转后的结果，该结果文本只会产生一次，窗口需要将结果文本正式插入到当前编辑的文本中。

  在合成过程中，可能产生多次结果文本。

  该消息可以在任何时刻产生，不一定在 `WM_IME_STARTCOMPOSITION` 到 `WM_IME_ENDCOMPOSITION` 之间产生。

  对多个输入法进行调查后，该消息要么在开始和结束之间产生（几乎全部中文和日语输入法都使用这个模式），要么在结束后额外产生一次（微软韩语输入法或类似的输入法采用该机制）。

  微软韩语输入法的触发的事件顺序为：开始、更新、更新...结束、更新。

  其更新消息只有两种情况：

  1. 带仅由一个字符的合成文本。

  2. 带仅有一个字符的合成文本，同时带仅有一个字符的结果文本。

  微软韩语输入法的输入逻辑和英文的输入逻辑类似，每次只输入一个字符。字符需要通过按下特定组合的按键才产生，当按键能够完整拼成某个韩语文字，并且用户继续输入下一个韩语文字时，输入法会将哪个完整的韩语文字写入到更新事件的结果文本中，而下一个待转换的韩语文字会写入到更新事件的合成文本中。如果不继续输入下一个韩语文字，而是按下标点、空格或回车，则仅将结果写入结果文本，合成文本为空。按下的标点、空格和回车不会被输入法处理，而是直接传递到窗口，即这些按键会按英文的输入逻辑，直接产生对应的字符。

当 合成开始消息 到达时，DLL 会通过回调函数通知插件，插件会注册 处理器-开始-计时器 产生 `TIMER` 消息，然后该消息会被更新器（是更新器不是处理器）捕获，然后启动处理器。处理将以模态的方式运行，直到收到 合成结束消息，或某些操作强制打断输入。

处理器仅和编辑器中使用输入法进行文本输入的行为相关，和输入框以及不使用输入法进行文本输入无关。

处理器的主要职责有两个：

1. 处理输入法的合成消息，并将其以可视化的方式呈现给用户。

2. 根据情况更新候选窗口的位置。

   这部分的逻辑请归入 “更新候选窗位置” 章节，请参考该章节的内容。

这里侧重讲解第一个目标的实现方式。

其基本逻辑是调用 Blender 提供的 BPY 接口，通过插入、删除、移动等操作来呈现合成文本和结果文本。

1. 更新事件到达时，删除之前临时插入到文本中的合成文本。

2. 然后如果更新事件带有结果文本，则真实地插入到文本中。如果更新事件带有合成文本，则临时地插入到文本中。

   “真实”指此次插入操作的 UNDO 参数为 True，且不会在合成结束前被删除。

   “临时”指此此插入操作的 UNDO 参数为 False，且会在下次更新或结束事件时被删除。

3. 结束事件到达时，删除之前临时插入到文本中的合成文本。

关于下划线的绘制，请参考处理器中相关绘制相关函数。

最后要讲解的内容是 DLL 中是如何处理相关的按键消息来完善 Blender 对输入文本输入的支持。

这部分内容和输入框和编辑器中使用输入法进行文本输入的行为相关。

按键的处理主要分为三个分支：

1. 停用输入法时，直接放行。

2. 启用输入法时，

    1. 当按键为非回放按键，如果必须放行，则直接放行，如果非必须放行，则直接拦截。

        拦截发生在 WM_INPUT 消息中，拦截按键指不让 Blender 处理该 WM_INPUT 消息。

        在后续的 WM_KEYDOWN 和 WM_KEYUP 中：
        
            - 如果按键被输入法处理，则不执行任何操作，按键在后续会触发输入法相关的合成事件。

                对于输入框，这些合成事件由 Blender 自身进行处理，插件无需干预。

                对于编辑器，这些合成事件由 DLL 通过回调函数通知插件，处理流程在上文中已进行描述。

            - 如果按键不被输入法处理，则这些按键会通过 SendInput 重新产生，这些模拟出来的按键在这里称作回放按键。

    2. 如果按键为回放按键（回放按键必然是输入法不处理的按键，即等效于英文输入模式下输入的按键）：

        1. 如果回放按键表明自己必须被拦截，则直接拦截。

            这种回放按键用于应对 [3.6.2 版开始的非重复型快捷键失效问题](#3.6.2-版开始的非重复型快捷键失效问题)。

        2. 如果回放按键表明自己必须被放行，则进行特殊处理后再放行。

            这个特殊处理指传递给 Blender 处理前，先停用输入法，在 Blender 处理后，再重新启用输入法。

            这样做是因为 Blender 在输入法启用时，会根据自己的逻辑，判断按键是否会被输入法处理，如果会被输入法处理，则交给其输入法合成事件处理流程，否者直接将按键转为字符。当这个判断逻辑和输入法使用的逻辑不同的时候，则会产生问题。譬如 Blender 的判断逻辑中认为所有字母按键都是会在输入法处于非英文输入模式时被输入法处理的（走合成事件），但多数中文输入法在大写锁定时，不会处理字母按键（不走合成事件），此时 Blender 的逻辑和实际输入法的逻辑就不同，结果是 Blender 等待输入法合成事件，而输入法此时不会产生输入法合成事件，最终该按键不产生任何效果。

            先停用输入法，可以绕过 Blender 的上述逻辑，因为该逻辑的前提是启用了输入法。停用了输入法后，Blender 会按照常规的方式处理按键，顺利产生字符输入。

# 3.6.2 版开始的非重复型快捷键失效问题

该问题源于以下修改（commit hash: 8191b152ecf）

    Fix #109525: Improved Win32 Repeat Key Filtering

    Allows Win32 key repeat filtering to support multiple simultaneously
    repeating keys, as can happen with modifiers. Removes
    m_keycode_last_repeat_key and instead checks current down status.

    Pull Request: https://projects.blender.org/blender/blender/pulls/109991

Blender 在 3.6.2 版中修改了按键重复的判断机制，从自己建立机制来判断改为使用系统的机制来判断。

这个修改导致了启用了本插件后，某些没有启用**重复**的按键映射项不会被触发（譬如复制：Ctrl + C），但启用了重复的按键映射项依然能够被触发（譬如粘贴：Ctlr + V）。

## 解决

通过在回放按键时多加一条按键消息来取消按键的按下状态，即可使得回放的按键处于非重复状态。

而重复产生的按键消息，无需多加一条按键消息，保持默认即可。

# 文本编辑模式中使用 Shift 加鼠标按键导航导致输入模式切换的问题

大部分中文输入法会在 Shift + 其它按键的情况下忽略 Shift 键，不会进行输入模式的转换，但是其它按键不包括鼠标按键。

因此此时使用 Shift + 鼠标按键 进行导航时，会意外导致输入模式被切换。

这里给出的解决办法是在 WM_LBUTTONDOWN 等消息时判断是否按下 Shift 键，如果是，则临时停用输入法。

当在 WM_KEYUP 时，如果释放的按键为 Shift 键，且之前临时停用了输入法，则重新启用输入法。

通过这种方式可以避免输入法模式被意外切换。
